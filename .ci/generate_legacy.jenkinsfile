/*

Notes on this job:
 - it will use an Artifactory to cache docker images an avoid building and building them from scratch
 - (because of the previous issue) several instances of this job cannot run in paralel (they might override the `latest` image uploaded)

*/


// Maybe parameterized somewhere
dockerUsername = 'center-c3i-docker.jfrog.io'
dockerhubUsername = 'conanio'


def parseVersion(String version) {
    def matcher = (version =~ /(\d+).(\d+).(\d+)/)
    return [matcher[0][1] as String, matcher[0][2] as String, matcher[0][3] as String]
}

String getVersionMajor(String version) {
    def (major, _1, _2) = parseVersion(version)
    return major
}


def buildImage(String latestMaster, String latestBranch, String expectedImage, String buildArgs, String target = null, String extraCacheFrom = null) {
    withCredentials([usernamePassword(credentialsId: 'center-c3i-docker', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
        sh 'docker login --username $USERNAME --password $PASSWORD ' + "${dockerUsername}"
    }

    String cacheFrom = extraCacheFrom ? " --cache-from ${extraCacheFrom}" : ''
    if (0 == sh(script: "docker pull ${latestMaster}", returnStatus: true)) {
        cacheFrom = "${cacheFrom} --cache-from ${latestMaster}"
    }
    if (0 == sh(script: "docker pull ${latestBranch}", returnStatus: true)) {
        cacheFrom = "${cacheFrom} --cache-from ${latestBranch}"
    }

    sh "docker build ${cacheFrom} -t ${expectedImage} ${buildArgs} ${target ? "--target $target": ''} ."

    sh "docker push ${expectedImage}"
    sh "docker tag ${expectedImage} ${latestBranch}"
    sh "docker push ${latestBranch}"
}


def get_container_id() {
    // This is quite fragile and might depends on the Jenkins configuration and deployment, but it is the best
    //  I can figure out to get the ID of the running container to be able to mount the same volume when
    //  using docker-in-docker.
    String nodeName = "${NODE_NAME}"
    String output = sh(script: 'docker ps --no-trunc', returnStdout: true)
    String nodeId = null
    output.split('\n').each({
        String line = it.trim()
        if (line.contains(nodeName) && line.contains('/opt/entrypoint.sh')) {
            nodeId = line.split(' ')[0]
        }
    })
    echo "Node ${nodeName} with docker ID '${nodeId}'"
    return nodeId
}

def checkoutSources() {
    if (params.scm_pr_number) {
        echo "Install reference from SCM repository. PR ${params.scm_pr_number} merging with 'master' branch"
        // TODO: Try using extension 'PreBuildMerge' (https://gist.github.com/martinda/b2ece95c2c71ddb4d4a762f0a02561b3)
        checkout([$class           : 'GitSCM',
                    branches         : [[name: params.scm_pr_commit]],
                    userRemoteConfigs: [[name         : 'origin', refspec: "+refs/pull/${params.scm_pr_number}/head:refs/remotes/origin/PR-${params.scm_pr_number} +refs/heads/master:refs/remotes/origin/master",
                                        credentialsId: 'GITHUB_CLONE', url: params.scm_repository]],
        ])
        sh 'git config user.email "any@notused.com"'
        sh 'git config user.name "CI bot"'
        sh "git merge --no-ff ${params.scm_commit}"
    }
    else {
        echo "Install reference from the SCM repository"
        checkout([$class           : 'GitSCM',
                    branches         : [[name: params.scm_commit]],
                    userRemoteConfigs: [[credentialsId: 'GITHUB_CLONE', url: params.scm_repository]],
        ])
    }
    sh 'git log -n 10 --graph --pretty=oneline --abbrev-commit --all --decorate=full'
}

node('Linux') {
    List<String> gccVersions = params.gcc_versions.split("\n")
    List<String> clangVersions = params.clang_versions.split("\n")


    stage('Legacy - Input parameters') {
        echo """
        About sources:
        - scm_repository: ${params.scm_repository}
        - scm_commit: ${params.scm_commit}
        - scm_base_branch: ${params.scm_base_branch}
        - scm_pr_number: ${params.scm_pr_number}
        - scm_pr_commit: ${params.scm_pr_commit}
        """
        if (params.scm_pr_number) {
            currentBuild.description = "${params.suffix} | PR-${params.scm_pr_number} - ${params.scm_pr_commit.substring(0, Math.min(8, params.scm_pr_commit.size()))}"
        }
        else {
            currentBuild.description = "${params.suffix} | ${params.scm_base_branch} - ${params.scm_commit.substring(0, Math.min(8, params.scm_commit.size()))}"
        }
        // TODO: currentBuild.description = "${}"

        echo """
        About base docker:
        - distro: ${params.distro}
        - distro_version: ${params.distro_version}
        """

        echo """
        About tools installed:
        - conan_version: ${params.conan_version}
        - cmake_version: ${params.cmake_version}
        - python_version: ${params.python_version}
        - jenkins_agent_version: ${params.jenkins_agent_version}
        """

        echo """
        Images to generate:
        - gcc_versions: ${gccVersions.join(', ')}
        - clang_versions: ${clangVersions.join(', ')}
        - libstdcpp_version: ${params.libstdcpp_version}
        - libstdcpp_patch_version: ${params.libstdcpp_patch_version}
        - libstdcpp_major_version: ${params.libstdcpp_major_version}
        """
        assert gccVersions.size() > 0: "Expecting to build some GCC versions at least"
        assert clangVersions.size() > 0: "Expecting to build some Clang versions at least"

        echo """
        About docker images generated:
        - suffix: ${params.suffix}
        - dockerUsername: ${dockerUsername}
        - dockerhubUsername: ${dockerhubUsername}
        """

        echo """
        Workflow control
        - upload_latest: ${params.upload_latest}
        - upload_main_images: ${params.upload_main_images}
        - upload_jenkins_images: ${params.upload_jenkins_images}
        - dry_run: ${params.dry_run}
        """
    }

    stage('Legacy - Checkout sources') {
        checkoutSources()
    }

    stage('Legacy - Install deps') {
        sh 'pip install docker-compose humanfriendly conan conan-package-tools'
    }

    // Get some global information, used later
    String suffix = params.suffix ? "-${params.suffix}" : ''
    String mainContainerID = get_container_id()
    String targetBranch = params.scm_base_branch.replaceAll('/', '-')
    String branchName = targetBranch
    if (params.scm_pr_number) {
        branchName = "PR-${params.scm_pr_number}"
    }

    boolean isMaster = (branchName == 'master')
    echo ">> branchName: ${branchName}, targetBranch: ${targetBranch} (isMaster: ${isMaster})"
    String commit = "n${env.BUILD_NUMBER}" // We need something unique for this execution, the commit is not enough (we can trigger again same commit)

    // Build build-args list
    Map<String, String> buildArguments = [:]
    Map<String, String> testArguments = [:]
    stage("Legacy - Build arguments") {
        buildArguments.put('CONAN_VERSION', params.conan_version)

        // TODO: Pass expected in a different way
        writeFile(file: '.env', text: testArguments.collect({ k, v -> "${k }=${v }"}).join('\n') as String)
        sh 'cat .env'
    }
    String buildArgs = buildArguments.collect({ k, v -> "--build-arg ${k }=${v }"}).join(' ') as String

    // Define helper function to build the compiler
    Closure compilerBuild = { String compiler, String version ->
        return {
            String versionMajor = getVersionMajor(version)

            String deployImage = "${dockerUsername}/${compiler}${versionMajor}:${branchName}-${commit}"
            String jenkinsImage = "${dockerUsername}/${compiler}${versionMajor}-jnlp-slave:${branchName}-${commit}"
            String compilerArgs = "${buildArgs}"

            node('Linux') {
                stage('Legacy - Checkout and install deps') {
                    checkoutSources()
                    sh 'cat .env'
                }

                String containerID = get_container_id()

                stage("Legacy - ${compiler.toUpperCase()} ${version} deploy") {
                    String latestBranch = "${dockerUsername}/${compiler}${versionMajor}:${branchName}-latest"
                    String latestMaster = "${dockerUsername}/${compiler}${versionMajor}:${targetBranch}-latest"

                    dir("${compiler}_${versionMajor}") {
                        buildImage(latestMaster, latestBranch, deployImage, compilerArgs, 'deploy')
                    }
                }

                stage("Legacy - ${compiler.toUpperCase()} ${version} jenkins") {
                    String latestBranch = "${dockerUsername}/${compiler}${versionMajor}-jnlp-slave:${branchName}-latest"
                    String latestMaster = "${dockerUsername}/${compiler}${versionMajor}-jnlp-slave:${targetBranch}-latest"

                    dir('jenkins-jnlp-slave') {
                        buildImage(latestMaster, latestBranch, jenkinsImage, "${compilerArgs} --build-arg SOURCE_CONANIO_IMAGE=${deployImage}")
                    }
                }
            }
        }
    }

    // Build GCC in parallel
    Map gccBuilds = [:]
    List<String> gccImages = []
    gccVersions.each { v ->
        String gccVersion = v
        String gccVersionMajor = getVersionMajor(gccVersion)
        gccImages.add("gcc${gccVersionMajor}")
        gccBuilds["Legacy GCC ${gccVersionMajor}"] = compilerBuild('gcc', gccVersion)
    }
    gccBuilds.failFast = true
    parallel(gccBuilds)


    // Build Clang in parallel
    Map clangBuilds = [:]
    List<String> clangImages = []
    clangVersions.each { v ->
        String clangVersion = v
        String clangVersionMajor = getVersionMajor(clangVersion)
        clangImages.add("clang${clangVersionMajor}")
        clangBuilds["Legacy Clang ${clangVersionMajor}"] = compilerBuild('clang', clangVersion)
    }
    clangBuilds.failFast = true
    parallel(clangBuilds)

    if (isMaster) {
        // If it was master and everything is ok up to here
        stage('Legacy - Upload images') {
            List images = []
            gccVersions.each { v ->
                String versionMajor = getVersionMajor(v)
                if (params.upload_main_images) {
                    images.add("gcc${versionMajor}")
                }
                if (params.upload_jenkins_images) {
                    images.add("gcc${versionMajor}-jnlp-slave")
                }
            }
            clangVersions.each { v ->
                String versionMajor = getVersionMajor(v)
                if (params.upload_main_images) {
                    images.add("clang${versionMajor}")
                }
                if (params.upload_jenkins_images) {
                    images.add("clang${versionMajor}-jnlp-slave")
                }
            }

            images.each { image ->
                String builtImage = "${dockerUsername}/${image}:${branchName}-${commit}"
                sh "docker pull ${builtImage}"

                withCredentials([usernamePassword(credentialsId: 'docker-credentials', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    sh 'docker login --username $USERNAME --password $PASSWORD'
                }

                // Upload with the corresponding tag version
                String uploadImage = "${dockerhubUsername}/${image}:${params.conan_version}"
                sh "docker tag ${builtImage} ${uploadImage}"
                if (!params.dry_run) {
                    sh "docker push ${uploadImage}"
                }

                if (params.upload_latest) {
                    // Upload with tag 'latest'
                    String uploadLatest = "${dockerhubUsername}/${image}:latest"
                    sh "docker tag ${builtImage} ${uploadLatest}"
                    if (!params.dry_run) {
                        sh "docker push ${uploadLatest}"
                    }
                }
            }
        }
    }

}
